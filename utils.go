package main

import (
	"bufio"
	"flag"
	"fmt"
	"github.com/jmcvetta/randutil"
	"github.com/syncato/lib/config"
	"os"
	"path/filepath"
	"strings"
)

type Options struct {
	createconfig bool
	port         int
	config       string
	loglevel     int
	logformat    string
	httplog      string
	applog       string
	// Indicates if the daemon should serve the web application.
	// If this is false, the daemon will just provide the APIs.
	// If this is false, you can serve the web application from a different server like
	// Apache or Nginx, but then you need to enable CORS.
	serveweb bool

	// If ServeWeb is enabled, indicates where is located the we application inside the filesystem.
	webdir string

	// If ServerWeb is enabled, indicates the URL where the web application will be served. Usually is /app/.
	weburl string
}

func getServerOptions() (*Options, error) {
	opts := Options{}

	flag.BoolVar(&opts.createconfig, "createconfig", false, "Creates a custom configuration file")

	flag.IntVar(&opts.port, "port", 8080, "Listening port for HTTP/HTTPS server")
	flag.StringVar(&opts.config, "config", "$HOME/.syncatod/config.json", "Configuration file")
	flag.IntVar(&opts.loglevel, "loglevel", 4, "Log level. Possible values: 0=panic,1=fatal,2=error,3=warning,4=info,5=debug")
	flag.StringVar(&opts.logformat, "logformat", "text", "Log format. Possible values: text or json")
	flag.StringVar(&opts.applog, "applog", "stdin", "File to output logs generated by the app")
	flag.StringVar(&opts.httplog, "reqlog", "stdin", "File to output requests Apache-like logs")

	flag.BoolVar(&opts.serveweb, "serveweb", false, "Serve web applications, not just the APIs")
	flag.StringVar(&opts.httplog, "webdir", "", "Location of web applications")
	flag.StringVar(&opts.httplog, "weburl", "/apps", "Path to serve the web applications")

	flag.Parse()

	return &opts, nil
}

func createConfigFile(filename string) error {
	reader := bufio.NewReader(os.Stdin)

	// Ask the location to save the configuration
	fmt.Printf("Where do you want to save the config file ? (%s) : ", DEFAULT_CONFIG_NAME)
	configFilename, err := reader.ReadString('\n')
	if err != nil {
		return err
	}
	configFilename = strings.TrimSuffix(configFilename, "\n")
	if configFilename == "" {
		configFilename = DEFAULT_CONFIG_NAME
	}
	configFilename = filepath.Clean(configFilename)

	// create random secret for signing tokens
	secret, err := randutil.AlphaString(60)
	if err != nil {
		return err
	}

	var cfg = &config.ConfigParams{}
	cfg.TokenSecret = secret
	cfg.TokenCipherSuite = DEFAULT_TOKEN_CIPHER_SUITE

	_, err = config.NewWithModel(filename, cfg, nil)
	if err != nil {
		return err
	}

	fmt.Println("Configuration created succesfully!")
	return nil
}
